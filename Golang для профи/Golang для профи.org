#+TITLE: Golang для профи
#+ROAM_TAGS: WIP BOOK


- tags :: [[file:20200610233705-golang.org][Golang]], [[file:20200619234526-books.org][Books]]


* Глава 1 [0/1]
Объединение стандартных потоков stderr и stdout в bash
#+begin_src bash
go run stdERR.go >/tmp/output 2>&1
cat /tmp/output
#+end_src


Включить в логе вывод номера строки можно:
#+begin_src go
iLog := log.New(f, "customLogLineNumber ", log.LstdFlags)
iLog.SetFlags(log.LstdFlags | log.Lshortfile)
#+end_src

#+begin_quote
На компьютерах с UNIX рекомендуется передавать сообщения об ошибках в службу журналирования,особенно если Go-программа является сервером или другим критически важным приложением.
#+end_quote

** Docker example
#+begin_src
FROM golang:alpine
RUN mkdir /files
COPY hw.go /files
WORKDIR /files
RUN go build -o /files/hw hw.go
ENTRYPOINT ["/files/hw"]
#+end_src

*Отправка образа докер в DockerHub*
#+begin_src bash
docker login
Authenticating with existing credentials...
Login Succeeded
docker tag go_hw:v1 "mactsouk/go_hw:v1"
docker push "mactsouk/go_hw:v1"
#+end_src
** TODO Ссылки [0/4]

- State "TODO"       from              [2020-11-04 Ср 17:03]


- [ ] https://golang.org/pkg/os/
- [ ] https://golang.org/pkg/log/
- [ ] https://golang.org/pkg/fmt/
- [ ] https://blog.golang.org/why-generics
* Глава 2
** Компилятор
Для компиляции файла go нужно вызвать ~go tool compile file.go~. В итоге получится объектный файл, в котором содержится /объектный код/, т.е. машинный код в переносимом формате, который чаще всего не может быть непосредственно выполнен.

Если выполнять с ключем ~-pack~, то на выходе получится *архивный файл*. Архивный файл - двоичный файл в котором содержится один или несколько других файлов. Файлы запаковываются в архив ~ar~.
** Сборка мусора
Го ищет объекты вне области видимости (на которых не ведет ни одна ссылка, на которые нельзя больше ссылаться) и освобождает занимаемую ими память.

В go используется *трехцветный алгоритм пометки и очистки*. Он может работать конкрурентно, и использует /барьер записи/. Это означает, что при запуске го программы, планировщик го составляет график работы приложения и сборщика мусора.

Основной принцип - разделение объектов в куче по цветам:
- /черные/ - гарантированно не имеют указатели ни на один объект /белого цвета/, но объект белого цвета может иметь указатель но черный;
- /серые/ - могут иметь указатели на некоторые объекты /белого цвета/;
- /белые/ - претенденты на удаление;


Когда начинается сборка - все объекты белые. Сборщик перебирает все корневые объекты и красит их в серый. /Корневые объекты/ - объекты, к которым приложение может обращаться напрямую, включая глобальные переменные.

*Мутатор* - приложение, которое работает во время сборки мусора. Отвечает за то, чтобы ни один элемент черного множества не имел указатель на элемент белого. Достигается с помощью функции барьера записи.
*Барьер записи* - функция, которую запускает мутатор. Функция выполняется каждый раз, когда меняется указатель в куче

Слайсы работают гораздо лучше со сборщиком мусора чем мапы. Мапы занимают гораздо больше времени.
** Небезопасный код (unsafe)
/Небезопасный код/ - Go код, который обходит безопасность типов и безопасность памяти Go.

Функция ~unsafe~ позволяет на свой страх и риск создать указатель любого типа.

#+begin_quote
Указатель типа ~unsafe.Pointer~ позволяет преодолевать систему типов Go. Это позволяет существенно увеличить производительность, но может быть опасно, если использовать указатели неправильно или небрежно. Кроме того, так разработчики получают больший контроль над данными.
#+end_quote

#+begin_quote
Указатель можно разыменовать с помощью символа *. Можно получить значение указателя или присвоить ему новое.
#+end_quote

Компилятор *генерирует* код пакета ~unsafe~ при компилляции.
