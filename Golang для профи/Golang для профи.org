#+TITLE: Golang для профи
#+ROAM_TAGS: WIP BOOK


- tags :: [[file:20200610233705-golang.org][Golang]], [[file:20200619234526-books.org][Books]], [[file:20201108181439-конспект.org][Конспект]], [[file:20201108181605-algorithms_and_data_structures.org][Algorithms and data structures]]


* Глава 1 [0/1]
Объединение стандартных потоков stderr и stdout в bash
#+begin_src bash
go run stdERR.go >/tmp/output 2>&1
cat /tmp/output
#+end_src


Включить в логе вывод номера строки можно:
#+begin_src go
iLog := log.New(f, "customLogLineNumber ", log.LstdFlags)
iLog.SetFlags(log.LstdFlags | log.Lshortfile)
#+end_src

#+begin_quote
На компьютерах с UNIX рекомендуется передавать сообщения об ошибках в службу журналирования,особенно если Go-программа является сервером или другим критически важным приложением.
#+end_quote

** Docker example
#+begin_src
FROM golang:alpine
RUN mkdir /files
COPY hw.go /files
WORKDIR /files
RUN go build -o /files/hw hw.go
ENTRYPOINT ["/files/hw"]
#+end_src

*Отправка образа докер в DockerHub*
#+begin_src bash
docker login
Authenticating with existing credentials...
Login Succeeded
docker tag go_hw:v1 "mactsouk/go_hw:v1"
docker push "mactsouk/go_hw:v1"
#+end_src
** TODO Ссылки [0/6]

- State "TODO"       from              [2020-11-04 Ср 17:03]


- [ ] https://golang.org/pkg/os/
- [ ] https://golang.org/pkg/log/
- [ ] https://golang.org/pkg/fmt/
- [ ] https://blog.golang.org/why-generics
- [ ] json
- [ ] time
* Глава 2
** Компилятор
Для компиляции файла go нужно вызвать ~go tool compile file.go~. В итоге получится объектный файл, в котором содержится /объектный код/, т.е. машинный код в переносимом формате, который чаще всего не может быть непосредственно выполнен.

Если выполнять с ключем ~-pack~, то на выходе получится *архивный файл*. Архивный файл - двоичный файл в котором содержится один или несколько других файлов. Файлы запаковываются в архив ~ar~.
** Сборка мусора
Го ищет объекты вне области видимости (на которых не ведет ни одна ссылка, на которые нельзя больше ссылаться) и освобождает занимаемую ими память.

В go используется *трехцветный алгоритм пометки и очистки*. Он может работать конкрурентно, и использует /барьер записи/. Это означает, что при запуске го программы, планировщик го составляет график работы приложения и сборщика мусора.

Основной принцип - разделение объектов в куче по цветам:
- /черные/ - гарантированно не имеют указатели ни на один объект /белого цвета/, но объект белого цвета может иметь указатель но черный;
- /серые/ - могут иметь указатели на некоторые объекты /белого цвета/;
- /белые/ - претенденты на удаление;


Когда начинается сборка - все объекты белые. Сборщик перебирает все корневые объекты и красит их в серый. /Корневые объекты/ - объекты, к которым приложение может обращаться напрямую, включая глобальные переменные.

*Мутатор* - приложение, которое работает во время сборки мусора. Отвечает за то, чтобы ни один элемент черного множества не имел указатель на элемент белого. Достигается с помощью функции барьера записи.
*Барьер записи* - функция, которую запускает мутатор. Функция выполняется каждый раз, когда меняется указатель в куче

Слайсы работают гораздо лучше со сборщиком мусора чем мапы. Мапы занимают гораздо больше времени.
** Небезопасный код (unsafe)
/Небезопасный код/ - Go код, который обходит безопасность типов и безопасность памяти Go.

Функция ~unsafe~ позволяет на свой страх и риск создать указатель любого типа.

#+begin_quote
Указатель типа ~unsafe.Pointer~ позволяет преодолевать систему типов Go. Это позволяет существенно увеличить производительность, но может быть опасно, если использовать указатели неправильно или небрежно. Кроме того, так разработчики получают больший контроль над данными.
#+end_quote

#+begin_quote
Указатель можно разыменовать с помощью символа *. Можно получить значение указателя или присвоить ему новое.
#+end_quote

Компилятор *генерирует* код пакета ~unsafe~ при компилляции.
** Defer
Отложенные функции выполняются в порядке /LIFO/.
* Глава 3
** Срезы
При append'e емкость среза удваивается до тех пор, пока его длина не достигнет 1024. Дальше увеличение происходит не больше чем на 25%
** Функция copy
Функция copy(dst, src) копирует n элементов из массива dst в src, где n = ~min(len(dst), len(src))~
** map
В nil мапу нельзя вставить элемент, НО можно делать все остальное: выполнить ~len~, ~delete~, ~range~
** константы
Для констант лучше не объявлять тип жестко. Это добавляет  дополнительную гибкость для использования значения константы в расчетах.

#+begin_quote
Общая рекомендация такова: если вы используете в программе много констант, хорошо бы объединить их в одном пакете или в структуре Go.
#+end_quote
* Глава 4
** Регулярные выражения
*Регулярные выражения* компилируются в распознаватель путем построения обобщенной диаграммы переходов, называемой конечным автоматом.

Конечные автоматы бывают двух типов:
- детерминированные
- недетерминированные - у одного набора данных может существовать несколько вариантов перехода из этого состояния.


*Распознаватель* - программа которая принимает на входе строку x, и решает, является ли х предложением из заданного языка.


*Грамматика* - набор порождающих правил представленных на формальном языке.
** Руны
Руна - int32, тип Go, который используется для представления /кодовых пунктов/ Unicode.
** Пакет unicode
Полезные методы
- ~IsPrint()~
* Глава 5
** Графы
*Граф* (G (V, E)) - конечное непустое множество вершин (или узлов) V и множество ребер E.

Существует два основных вида графов:
- циклические - граф, в котором все или несколько вершин образуют замкнутый контур;
- ациклический - нет замкнутых контуров.


/Направленный граф/ - граф с ребрами которого связано некое направление, а /направленный ациклический граф/ - направленный граф без замкнутых контуров.

Поскольку узел может содержать любую информацию, *узлы обычно реализуются на основе структур Go* благодаря их универсальности.
** Сложность алгоритма
Эффективность алгоритма оценивается по его вычислительной сложности, которая главным образом определяется тем, *сколько раз алгоритму требуется доступ к входным данным для выполнения его работы*.

Для описания ясложности алгоритма в информатики используется /нотация "Большое О"/. Так, алгоритм со сложностью /O(n)/, которому требуется лишь однократный доступ к входным данным, считается лучше, чем алгоритм со сложностью /O(n^2)/. Наихудшими являются алгоритмы со сложностью /O(n!)/. Это делает их практически непригодными, когда объем входных данных превышает 300 элементов.


#+begin_quote
Несмотря на то что у каждого алгоритма есть свои недостатки, если только речь не идет о большом количестве данных, сложность алгоритма не особенно важна — лишь бы он точно выполнял свою работу.
#+end_quote
** Двоичные деревья
/Двоичное дерево/ - структура данных, в которой под каждым узлом располагается *не более двух* других узлов.
/Корень дерева/ - первый узел.
/Глубина дерева/ (Высота дерева) - самый длинный путь от корня до узла.
/Лист дерева/ - узел дерева без дочерних узлов.
/Сбалансированное дерево/ - дерево в котором наибольшая длина от корневого узла до листа не более чем на единицу превышает самую короткую длину. Иначе дерево является /несбалансированным/.


Балансировка дерева может быть сложной и дорогой операцией, поэтому дерево лучше изначально поддерживать сбалансированным.

Если дерево сбалансировано, то операции поиска, вставки, удаления выполняются за log(n) - где n количество элементов которое содержит дерево.
Высота двоичного дерева приблизительно равна log_2(n), т.е. высота сбалансированного дерева из 10 000 элементов равна 14.


*Основным недостатком* дерева является то, что вид дерева зависит от последовательности вставки
