#+BRAIN_CHILDREN: GORM

#+BRAIN_PARENTS: b911cce5-7b21-4688-b7aa-b5c6d554e1e6
* Основы
[[https://go-tour-ru-ru.appspot.com/concurrency/11][Ссылки из базового курса]]
** Синтаксис
- программа начинает работу в "пакете" ~main~;
- По соглашению, имя пакета совпадает с последним элементом пути импорта;
- группировка импортов в скобках *TRUE WAY*;
- имя экспортируется из файла если начинается с заглавной буквы;
- в аргументах указывается тип, также если функция что-то возвращает также должен указываться тип;
- если функция возвращает несколько значений, то оператор присваивания для двух значений будет :=;
- в go возвращаемые значения могут быть "переменными". Для этого нужно напрямую в определении функции прописать какие переменные будут возвращаться и их тип:
  #+begin_src go
    // лучше использовать только в мелких функциях как эта
    func split(sum int) (x, y int) {
      x = sum * 4 / 9
      y = sum - x
      return
    }
  #+end_src
*** Переменные
- Переменные могут определяться как внутри функции так и на уровне пакета. Для объявления переменных на уровне пакета необходимо обязательно указывать ~var~ или ~const~.
- Если при объявлении переменной /на уровне функции/ есть инициализирующее значение, то тип можно не указывать;
- При создании переменной без явного приведения типа, тип будет взят из значения в правой стороне;
- *Объявление переменных* можно и нужно группировать как импорты:
  #+begin_src go
    package main

    import (
      "fmt"
      "math/cmplx"
    )

    var (
      ToBe   bool       = false
      MaxInt uint64     = 1<<64 - 1
      z      complex128 = cmplx.Sqrt(-5 + 12i)
    )

    func main() {
      fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
      fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
      fmt.Printf("Type: %T Value: %v\n", z, z)
    }
  #+end_src
- Выражения ~[]color.Color{...}~ и ~gif.GIF{...}~ являются составными литералами (composite literals) — компактной записью для инстанцирования составных типов Go из последовательности значений элементов. В приведенном примере первый из них представляет собой срез, а второй — структуру.
- Объявлять переменные можно прямо в строке с ~if~:
  #+begin_src go
    if err := aaa(); a != nil {...}
  #+end_src

** Типы
#+begin_src go
  bool

  string

  int  int8  int16  int32  int64
  uint uint8 uint16 uint32 uint64 uintptr

  byte // псевдоним для uint8

  rune // псевдоним для int32
  // представляет Unicode код

  float32 float64

  complex64 complex128
#+end_src
Помимо базовых типов можно определять свои типы. Они могут быть *структурами* и *интерфейсами*
(позже может добавиться что-то другое)
** Циклы
В GO *только один цикл* -- for.
Он подобен циклам в C-подобных языках, и имеет три блока:
- блок инициализации: выполняется перед запуском цикла;
- условный блок: выполняется перед запуском каждой итерации;
- завершающий блок: выполняется в конце каждой итерации.
  #+begin_src go
    func main() {
      sum := 0
      for i := 0; i < 10; i++ {
        sum += i
      }
      fmt.Println(sum)
    }
  #+end_src
  
Блоки инициализации и завешения /опциональны/.
#+begin_src go
  func main() {
    sum := 1
    for ; sum < 1000; {
      sum += sum
    }
    fmt.Println(sum)
  }
#+end_src
*** For это while
В этом случае точки с запятой можно _опустить_:
#+begin_src go
  func main() {
    sum := 1
    for sum < 1000 {
      sum += sum
    }
    fmt.Println(sum)
  }
#+end_src

Если опустить условный блок, то получится _бесконечный цикл_:
#+begin_src go
  for {}
#+end_src
** Switch
Конструкция ~switch-case~ выглядит как и в js, с тем отличием, что после выполнения условия
вырожение заканчивается автоматически. Чтобы оно продолжило выполняться нужно указать ключевое слово
~fallthrough~
#+begin_src go
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("TOTALLY SHIT")
	case "linux":
		fmt.Println("BRO")
		fallthrough // позволяет switch-case'у идти дальше
	default:
		fmt.Printf("%s\n", os)
	}
#+end_src

Также может выполняться без условия. Может использоваться вместо длинного условия ~if-then-else~
Такая конструкция называется "переключателем без тэгов", эквивалентна ~switch true~
#+begin_src go
	a := 10
	switch {
	case a == 1:
		fmt.Printf("%s\n", "AAA")
	case a == 10:
		fmt.Printf("%s\n", "SUCCESS")
		fallthrough
	default:
		fmt.Printf("%s\n", "DONE")

	}
#+end_src
** Асинхронщина!
Оператор ~defer~ - откладывает выполнение функции. Что-то вроде ~setTimeout(func, 0)~ в js.
Аргументы функции вычисляются сразу, а сама функция выполняется после выхода из её контекста.

Отложенные вызовы в функции накапливаются в стеке по мере работы функции. Функции начинают
отрабатывать после возврата (~return~) из функции.

Отложенные функции из стэка выполняются в порядке LIFO.
** Указатели
Указатель содержит адрес переменной в памяти.
#+begin_src go
	/* звездочка это указатель на значение. Дефотное значение int это nil, поэтому p сейчас это
	   ссылка на объект nil в памяти
	*/
	var p *int
	fmt.Println(p)
	var concrete_var = 1488
	// в этом случае переменная link становится указателем и применяться должна соответсвующе. Для
	// получения значения всегда со звездочкой для присвоения ссылки нужно использовать оператор &
	var link = &concrete_var
	fmt.Println(*link)
	// через указатель можно присваивать значения базовой переменной
	*link = 666
	fmt.Println(concrete_var)
#+end_src
Значит, для создания ссылки из переменной необходимо использовать ~&~ при присвоении. При
использовании нужно использовать оператор ~*~ для получения значения привязанной переменной. 

Конструкция ~&var~ - называется присваивание. ~*var~ - разыменование.
** Структуры
Структуры это коллекции полей. Определяется ключевым словом ~strunc~. Структура представляет собой коллекцию полей ключ-значение.

Доступ к полям ссылки структуры выполняется тем же образом, что и к полям самой структуры без допонительных синтаксических оберток.

При создании экземпляра структуры можно указывать не все поля. Для этого поля нужно именовать через ~:~
*** Struct tags
Тэги добавляют мета информацию для пакета который их использует.

Тэги могут быть получены с помощью встроенное библиотеки ~reflect~. Полагаю, эта библиотека что-то вроде ~inspect~ в питоне. 

Тэги форматируются в обыкновенном формате `ключ: 'значение'`. У одного поля их может быть несколько, и они могут разделяться пробелами, например: ~key1:"value1" key2:"value2" key3:"value3"~.

Как я понял, это просто метаинформация для полей. Вот в случае с ~GORM~ для кажого поля можно определять метаинформацию таким же образом как в ~Django ORM~ определяются обычные поля только через ~models.Field~.

Чтобы получить тэги нужна какая-то ебучая, сложная конструкция:
#+begin_src go
  package main

  import "reflect"


  type Shit struct {
    Smell string `color:"green" kind:"kid"`
    Weight float64 `meter:"kilogramm"`
  }

  func main() {
    shit := Shit{}
    shitType := reflect.TypeOf(shit)
    field := shitType.fieldByName("Smell")
    tag, _ := field.Tag.Lookup("color")
    // или
    tag := field.Tag.Get("color")
  }
#+end_src

** Массивы
Для объявления массива используется следующий синтаксис
#+begin_src go
  var arr [10]int // массив длиной 10 внутри число
  var arr1 [5]string // массив длиной 5 внутри строка
  arr2 := [7]int{1,2,3,4,5,6,7} // массив длиной 7 и заполнение цифрами
#+end_src

*** Срезы
*Срез* - последовательность (с динамическим размером) s элементов массива.

Присутствует синтаксис срезов. Работает, в принципе, как и в питоне.
#+begin_src go
  var arr = [10]int
  kkk := arr[0:3]
#+end_src

*Срезы* это как указатели на массивы. Следовательно всё что изменится в срезе изменится и в
остальных связанных массивах.

*Литералы срезов*
ВНЕЗАПНО! Срезы можно создать без создания массива напрямую:
#+begin_src go
  arr := [3]bool{false, true, true} // это массивах
  arr2 := []bool{false, true, true} // тут создается сначала массив, а потом от него делается срез
#+end_src

Срезы можно создавать из структур.

Срез имеет размер (длину) и вместимость.
*Размер среза* - это количество элементов, которые он содержит.
*Вместимость среза* - это количество элементов в его нижележащем массиве, начиная с первого элемента в
срезе.
*Нулевые срезы*. Длина такого среза равняется 0, и у него нет нижележащего массива.


/Срезы/ могут содержать другие /срезы/.
*Динамические массивы*
Динамические массивы могут быть созданы при помощи функции ~make~. Функция ~make~ создает
/обнуленный/ массив и возвращает срез, который ссылается на этот массив

*Обход массивов и маппингов* можно с помощью ~range~
#+begin_src go
	for k, v := range slice {
		fmt.Println(k, v)
	}
#+end_src
** Карты (словари)
Для создания карт надо использовать ~make~
#+begin_src go
	shit := make(map[string]int)
#+end_src
Код выше создаст словарь ~shit~, с ключами типа ~string~ и значениями типа ~int~

Карта /может содержать структуру/ в качестве значения
#+begin_src go
  type Shit struct {
    Smell string
    Weight float32
  }

  var mapping = map[string]Sthit{
    "YourShit": Shit{"NASTY!", 0.5},
    "SONOFYOURMOTHERFRIED": Shit{"NICE!", 2.0}
  }
#+end_src
*Если тип верхнего уровня всего лишь имя типа* то его можно не указывать для элементов литерала
#+begin_src go
  type Shit struct {
    Smell string
    Weight float32
  }

  var mapping = map[string]Sthit{
    "YourShit": {"NASTY!", 0.5},
    "SONOFYOURMOTHERFRIED": {"NICE!", 2.0}
  }
#+end_src

Проверка, есть ли ключ в словаре
#+begin_src go
  var t, ok = mapping["testKey"] // проверка наличие ключа в переменной `ok`
  t, ok := mapping["testKey"] // или так
  delete(mapping["testKey"]) // удаление ключа
#+end_src
** Функции
Функции могут быть использованы как аргументы или возвращаемые значения. 
#+begin_src go
  // testFunc ...
  func testFunc(fn func(float64, float32) float64) func {
    f := func name(test int) int {
        return test
      }
    return f
  }

#+end_src
*** Методы
*Метод* - это всего лишь функция, для которой указан получатель. Метод можно объявить только в том
 же пакете, где объявляется и тип к которому привязывается метод.
 
*Методы, которые получают НЕ указатели не могут модифицировать внутренности типа!!!*
#+begin_src go
  type Shit struct {
    Smell string
    Value float32
  }

  func (self Shit) GetSmell() string {
    return self.Smell
  }
#+end_src
Методы можно объявлять не только структурам, но и типам.
#+begin_src go
  var MyFloat float64

  func (self MyFloat) Shit () string {
	    return "shit"
  }
#+end_src

Можно объявлять методы, где в качестве получателей выступают указатели. Методы с
получателями-указателями /могут модифицировать значение/, на которое указывает получатель
#+begin_src go
  type Shit struct {
      Smell string
      Weight float64
  }

  func (self *Shit) EatShit(newSmell string) {
	    self.Smell = newSmell
  }
#+end_src

При использовании *НЕ* указателя, метод работает *с копией* объекта (это такое же поведение как и
для любой другой функции).
*** Указатели и фукции
В этом примере метод ~SetSmell~ переписан как функция
/Функции с аргументом указателем должны принимать указатель (~&~)/
#+begin_src go
  type Shit struct {
      Smell string
      Weight float64
  }

  func (self *Shit) SetSmell(newSmell string) {
      self.Smell = newSmell
  }

  shit := Shit{"TASTY", 15}
  SetSmell(&shit, "NASTY!!") // здесь
#+end_src
** Интерфейсы
Немного сложный для понимания пример.
В 22 строке _ошибка_, т.к. метод структуры ~Vertex~ принимает указатель, но у самой структуры нет
такого метода.
#+begin_src go
  package main

  import (
    "fmt"
    "math"
  )

  type Abser interface {
    Abs() float64
  }

  func main() {
    var a Abser
    f := MyFloat(-math.Sqrt2)
    v := Vertex{3, 4}

    a = f  // a MyFloat implements Abser
    a = &v // a *Vertex implements Abser

    // In the following line, v is a Vertex (not *Vertex)
    // and does NOT implement Abser.
    a = v

    fmt.Println(a.Abs())
  }

  type MyFloat float64

  func (f MyFloat) Abs() float64 {
    if f < 0 {
      return float64(-f)
    }
    return float64(f)
  }

  type Vertex struct {
    X, Y float64
  }

  func (v *Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
  }
#+end_src
*Интерфейсы реализуются неявно*
Тип реализует интерфейс путем реализации всех его методов. Нет явного объявления о намерении
реализовать интерфейс, и нет ключевого слова ~implements~.
#+begin_src go
  package main

  import "fmt"

  type I interface {
    M()
  }

  type T struct {
    S string
  }

  // This method means type T implements the interface I,
  // but we don't need to explicitly declare that it does so.
  func (t T) M() {
    fmt.Println(t.S)
  }

  func main() {
    var i I = T{"hello"}
    i.M()
  }
#+end_src
*** Интерфейсное значение
Возможно, это совокупность конкретного типа и экзепляра этого типа. Такая совокупность представляет
собой /какой-то/ интерфейс. Неважно, описан он или нет, но при проверке интерфейса будет проверяться
именно эта совокупность. (я не уверен, что это именно так, досужие домыслы)

Или. Интерфейсное значение, это то, что присваивается к переменной с конкретным интерфейсом. Типа
значение переменной-интерфейса. И при вызове какого-либо интерфейсного метода, идёт банальный
"проброс" вызова через этот интерфейс.

Или. Интерфейсное значение приходит на вход метода интерфейса (это своего рода ~self~)

Методы могут вызываться у объекта с нулевым значением. Тогда в метод будет передаваться ~nil~. Нужно
писать для этого проверки. (Че, блядь, в каждом методе?)

Интерфейсное значение nil не содержит ни значения, ни конкретного типа.

*** Пустой интерфейс 
Пустой интерфейс - интерфейс который не содержит ни одного метода. Может содержать значения любого
типа. Пустые интерфейсы используются где необходимо работать со значениями неизвестного типа.
Например ~fmt.Println~.
*** Утверждение типа
"Утверждение типа" это по сути проверка, содержит ли интерфейс конкретный тип и получение _значения_
из _интерфейсного значения_:
#+begin_src go
  var a interface{} = "shit"
  b := a.(string)  // к b присвоится значение "shit"
  c := a.(float64) // будет panic
  // переменная "ok" будет отвечать на вопрос, есть ли внутри интерфейсного значения указанный тип
  d, ok := a.(float64)
#+end_src
Из вышеследующего вытекает возможность использовать _switch с типами_
*** Switch с типами
#+begin_src go
  func do(i interface{}) {
    switch t := i.(type) {
    case string:
      fmt.Println("FUKKEN STRING", t)
    case int:
      fmt.Println("INTTTTTT", t)
    default:
      fmt.Println("IDUNNO", t)
    }
  }
#+end_src
*** Интерфейс Stringer
Самый распространенный тип интерфейса. ~Stringer~ это тип, который может описать себя строкой.
Должен принимать только сам объект, но не ссылку на него
#+begin_src go
  type Stringer interface  {
    String() string
  }
#+end_src
*** Ошибки
Программы на Go выражают состояние ошибки с помощью значения типа ~error~. Ошибки в пщ походу всегда
передаются как второй результат.

Интерфейс ошибки представляет собой структуру с полями ~When~ и ~What~ и методом ~Error~.

Также функции могут вместо ~nil~ возвращать ошибки.
*** Reader
Пакет ~io~ объявляет интерфейс ~io.Reader~, который представляет сторону потока данных,
предназначенную для чтения.
** Goroutines
Горутина это легкий поток, управляемый средой выполнения Go. 
#+begin_src go
  go f(x, y, z)
#+end_src
создает новую go-процедуру и запускает в ней 
#+begin_src go
  f(x, y, z)
#+end_src

~f~, ~x~, ~y~, и ~z~ определяются в текущей go-процедуре, а выполнение f происходит в новой
go-процедуре.
*** Каналы
Хоть я мало работал с пайпами в питоне, но думаю можно провести аналогию с ними. Каналы здесь это
всё равно что пайпы в питоне. Поток данных определенного типа.

Судя по всему канал это что-то навроде очереди с данными. Извлекаться эти данные будут в порядке
FIFO.

*Каналы* это типизированные "трубы", по которым вы можете посылать и получать значения с помощью
оператора <-. 
#+begin_src go
  ch <- v    // Послать v в канал ch.
  v := <-ch  // Получить из канала ch, и
            // присвоить значение переменной v.
#+end_src
Канал необходимо создать также как мапы или массивы
#+begin_src go
  make(chan, int)
#+end_src
**** Буферизированные каналы
Буферизированные каналы это каналы с определенным размером стэка. Для создания такого можно
использовать функцию ~make~ со вторым аргументом (размер буфера):
#+begin_src go
  make(chan int, 10)
#+end_src
/Запись/ в такой буфер /блокируется/ если он полон, а /чтение/ если он /пуст/.
**** Range и Close
Каналы могут быть _закрыты_ тем, кто посылает в него данные. Это будет значить, что значений туда
поступать больше не будет.

Для проверки закрыт канал или нет нужно использовать стандартный синтаксис со вторым аргументом:
#+begin_src go
  // переменная ok будет false, если значений больше нет и канал закрыт
  data, ok := <- ch
#+end_src

Конструкция ~for i := range ch~ будет получать данные из канала до тех пор пока в нем есть данные.

Каналы нужно закрывать _только в том случае_ когда необходимо указать, что данных больше не будет,
например для завершения цикла ~range~.

*Закрывается* канал функцей ~close(ch)~

Судя по всему вместимость канала нужно указывать всегда, иначе он будет 1 или 2.
**** Select
Позволяет горутине находиться в ожидании окончания нескольких операций передачи данных.

Т.е. ~select~ может выбрать канал, в который сейчас можно записать, и в зависимости от этого
выполняется тот или иной код.

~select~ может выбирать между блоками чтения и записи. Главное чтобы блок был просто готов.

Когда создается канал ~make(chan int)~ он создается размерностью 1 (или 2), и запись в него просто
блокируется до тех пор, пока предыдущее значение не считают. Тоже и работает для чтения: нельзя
считать из канала пока он пустой. Цикл select так и работает. Он просто ждет пока ответит хотя бы
какой-нибудь канал, и работает с ним. Затем цикл повторяется.

Также в ~select~ имеется блок по-умолчанию. Запускается как обычно, если ни один другой блок не
готов. Использовать ~default~ нужно для отправки и получения данных _без блокировок_:
#+begin_src go
  select {
  case i := <-c:
      // используйте i
  default:
      // получение из c вызвало бы блокировку
  }
#+end_src
#+begin_src go
  package main

  import (
    "fmt"
    "time"
  )

  func main() {
    tick := time.Tick(100 * time.Millisecond)
    boom := time.After(500 * time.Millisecond)
    for {
      select {
      case <-tick:
        fmt.Println("tick.")
      case <-boom:
        fmt.Println("BOOM!")
        return
      default:
        fmt.Println("    .")
        time.Sleep(50 * time.Millisecond)
      }
    }
  }

#+end_src
*** sync.Mutex
Но что если нам не нужна связь? Что если мы только хотим убедиться, что, во избежание конфликтов,
только одна go-процедура имеет доступ к переменной в любой момент времени?

Эта концепция известна как *взаимное исключение*, и общепринятым названием для структуры данных,
которая это позволяет, является мьютекс (mutex).

К одной структуре данных, может получать доступ множество горутин. Чтобы избежать путаницы нужно
ставить локи для выполнения кода который может быть асинхронным. Судя по всему структуры с
потокобезопасными методами обозначают префиксом ~Safe~ в названии. Но это не точно.
#+begin_src go
  package main

  import (
    "fmt"
    "sync"
    "time"
  )

  // SafeCounter is safe to use concurrently.
  type SafeCounter struct {
    v   map[string]int
    mux sync.Mutex
  }

  // Inc increments the counter for the given key.
  func (c *SafeCounter) Inc(key string) {
    c.mux.Lock()
    // Lock so only one goroutine at a time can access the map c.v.
    c.v[key]++
    c.mux.Unlock()
  }

  // Value returns the current value of the counter for the given key.
  func (c *SafeCounter) Value(key string) int {
    c.mux.Lock()
    // Lock so only one goroutine at a time can access the map c.v.
    defer c.mux.Unlock()
    return c.v[key]
  }

  func main() {
    c := SafeCounter{v: make(map[string]int)}
    for i := 0; i < 1000; i++ {
      go c.Inc("somekey")
    }

    time.Sleep(time.Second)
    fmt.Println(c.Value("somekey"))
  }
#+end_src
* Книга
** Глава 1
*** Пакеты, модули
Каждый исходный файл начинается с объявления ~package~, который определяет, к какому пакеты принадлежит исходный файл.

*Пакет* — код Go организован в виде пакетов, это своего рода аналог модулей или библиотек в других языках. Пакет состоит из одного или нескольких фалов ~*.go~ в одном каталоге, которые определяют, какие действия выполняет данный пакет.

*Пакет main* определяет исполняемый файл. В нем обязательно должна присутствовать функция ~main~, которая является /точкой запуска/ программы.

*После импорта* пакета, путь к которому содержит несколько компонент (наподобие ~image/color~) , мы обращаемся к пакету по имени последнего компонента.

*** Форматирование строк
По соглашению, все функции заканчиющиеся на ~f~ используют язык форматирования строк, а все функции имена которых кончаются на ~ln~ форматируются так, будто используют "глагол" ~%v~, и в конце к ним добавляется символ переноса строки.
*** Упражнения
- [ ] Где-то вначале:
  - [ ] 1.1
  - [ ] 1.2
  - [ ] 1.3
- [X] 1.4 34(36)
- [ ] 39(37):
  - [ ] 1.5
  - [ ] 1.6
- [X] 41(39)
  - [X] 1.7
  - [X] 1.8
  - [X] 1.9
- [X] 43(41)
  - [X] 1.10
  - [X] 1.11
- [ ] 
** Глава 2. Структура программы
*** Объявления
Объявленные сущности на уровне пакеты видны внутри всего пакета без дополнительных импортов. Т.е. они все могут находиться в разных файлах. В этом случае не обязательно, чтобы объявления были с заглавной буквы. Заглавная нужна лишь для объявления для доступа *из-за пределов* пакета.

~:=~ - краткое объявление
~=~ - присваивание

Два указателя равны только тогда, когда указывают на одну и ту же переменную, или оба равны ~nil~.

Функции могут возвращать ссылки на локальные переменные. Таким образом эти локальные переменные будут жить после выполнения функции.

Функция ~new~ может создавать *неименованные* переменные. ~new(T)~ создаст переменную типа ~T~ с нулевым значением и вернет адрес типа ~*T~.

Если переменная из внутреннего скоупа каким либо способом (ссылочным) попадает во внешний скоуп, то это называется /сбеганием/ (escapes). Переменная /сбегает/ от функции в которой она была объвялена. Каждая сбегающая переменная /требует дополнительной памяти/, т.е. сбегающие переменные хранятся в куче, а несбегающие в стэке.

Для экономии памяти нужно не хранить ссылки на короткоживущие объекты внутри долгоживущих объектов.
*** Присваивание
*Присваивание кортежом* работает как в питоне в большинстве случаев. Выделить можно несколько моментов:
- ~v, ok = m[k]~ - поиск в отображении;
- ~v, ok = x.(T)~ - утверждение о типе (?);
- ~v, ok = <-ch~ - получение из канала.
 
*Присваиваемость*
Тип присваемого объекта должен соответствовать типу переменной, за исключением пустых интерфейсов и каналов, они могут иметь значение ~nil~.

Возможность использовать операцторы ~==~ и ~!=~ напрямую связан с присваиваемостью. Если можно присвоить значит мжоно и сравнить.
*** Объявления типов
Объявление ~type~ определяет новый /именованный/ тип, который имеет тот же базовый тип что и существующий.

*Именованный тип* позволяет отличать различные, и возможно несовместимые использования базового типа с тем, чтобы они не могли оказаться случайно смешанными.

*Объявление*
~type имя базовый_тип~

Именованный тип чаще всего появляется на уровне пакета.
Разные типы с одинаковыми базовыми типами не могут смешиваться в других перменных, то есть не могут сравниваться и над ними не могут производиться арифметические операции.

Для таких операция необходимое явное приведение типа ~Type(t)~.
*Преобразование* типа разрешено только в том случае, если у разных типов одинаковые базовые типы, или если они являются именованными указателями на переменные одного и того же типа.
*** Пакеты
Исходный текст пакета располагается в одном или нескольких файлах ~.go~, обычно в каталоге, имя которого является окончанием пути импорта, например файлы пакета ~gopl.io/chl/helloworld~ располагаются в каталоге ~$GOPATH/src/gopl.io/chl/helloworld~.

Каждый пакет служит в качестве отдельного пространства имен для своих объявлений

По соглашению имя пакета соответствует последней части пути импорта, так что легко предсказать, что именем пакета ~gopl.io/ch2/tempconv~ является ~tempconv~.

*** Импорт
В программе Go каждый пакет идентифицируется уникальной строкой, которая называется его /путем импорта/.

В зависимости от используемого инструмента программирования импорты в хаголовках программы могут значить что угодно. Спецификация языка этого не описывает.

При использовании CL инструмента *go* строки импортах значат каталог или путь, содержащий файлы программы *.go*

В каждом пакете может находиться любое количество функций ~init~ вида:
#+begin_src go
  func init() { /*...*/ }
#+end_src
Эти функции будут выполняться один раз при запуске программы.
*** Упражнения
- [ ] 66(68) 2.1
** Стиль написания Go программ
- использование автоформата с помощью ~gofmt~ **обязательно**;
- хорошей практикой является объявлять переменные внутри конструкции ~if~ в случае обработки ошибок;
- имена переменных чем короче тем лучше. Чем выше скоуп переменной, тем длиннее и значимее она должна выглядеть;
- camelCase предпочтительнее snake_case'a;
- обычная практика программирования в Go заключается в работе с ошибкой в конструкции if с последующим выходом из функции так, чтобы успешный путь выполнения не сопровождался отступом.
*** Документация
Документация пакета должна помещаться в главный файл пакета, перед объявлением ~package~. Такая строка должна быть только одна в пакете, либо выноситься в файл, если описание очень большое, в соответствии с godoc.
** Заметки
- **Правильная расстановка переноса строки важна**, т.к. переносы строк при компиляции преобразуются в точки с запятой (не точно). Поэтому открывающая фигурная скобка функции должна находиться с ней на одной строке.
- Интерфейс *io.Writer* очень важная вещь (дополнить)
** Вопросы
В: Описать разницу между ~Printf~ и ~Fprintf~
О: ~Printf~ (и связанные) осуществляют запись в текущий ~stdout~, а в функции начинающиеся с ~F~ можно выбрать назначение. Только это назначение должно реализовать *базовый интерфейс в GO Writer*, т.е. иметь метод ~Write~, но это не точно.

В: *Выходной поток*. Судя по всему центральная сущность в GO. Дать определение, понять и принять!
О:

В: В какие потоки можно записывать данные с помощью функции ~fmt.Fprintf~
О: В любую сущность, главное чтобы она реализовывала /интерфейс/ *io.Writer* ~os.Stdout~, в файл, ~ioutil.Discard~, даже в ~http.ResponseWriter~. Все они должны иметь метод ~Write()~.

В: Неименованные переменные?
О:

В: как происходит обычный workflow разработки на go. где смотрится документация? непосредственно в коде и ли най сайте
** Стратегии обработки ошибок
- передавать err, val предыдущей функции
- передавать err предыдущей функции + добавить своё форматирование с помощью fmt.Errorf
- сделать лог ошибки в ~stderr~ и выйти из программы os.Exit(0)
- отправить ошибку в ~stderr~ без выхода из программы
* Заметки/сниппеты
Приходит осознание, что go вращается вокруг reader'ов и writer'ов. Может быть это ощущение обманчивое. Также при этом стоит помнить про утиную типизацию, почти как в питоне. Т.е. чтобы соответсовать какому-то типу достаточно выполнять его "интерфейс" (иметь методы и поля которые есть у типа).
